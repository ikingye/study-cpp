"use strict";(function(){const t={cache:!0};t.doc={id:"id",field:["title","content"],store:["title","href","section"]};const e=FlexSearch.create("balance",t);window.bookSearchIndex=e,e.add({id:0,href:"/study-cpp/docs/basic/",title:"第一部分 基础入门",section:"Docs",content:`C++ (/ˌsiːˌplʌsˈplʌs/) 的发明人是 Bjarne Stroustrup (/ˈbjɑːrnə ˈstraʊstrʊp/, 1950/12/30, http://www.stroustrup.com)，
C++ 的历史可以追溯到 1979，最初的灵感来自一种叫作 Simula 的语言。 起初，Bjarne Stroustrup 把他发明的语言称为 Cfront，1983 年更名为 C++。
1998 年，C++ 标准委员会发布了第一个 C++ 国际标准 ISO/IEC 14882:1998，俗称 C++98。 C++98 包含了标准模板库 (Standard Template Library，STL)。
2003 年，C++ 标准委员会修正了 C++98 的若干错误，发布了第二个 C++ 国际标准 ISO/IEC 14882:2003，俗称 C++03。
之后，C++ 发展缓慢，直到 2011 年，C++ 标准委员会发布了第三个 C++ 国际标准 ISO/IEC 14882:2011，俗称 C++11。 C++11 是一次大改动，给 C++ 增加了一些很有用的功能，比如：右值引用 (Rvalue)、Lambda、对多线程的支持（包括原子操作）和智能指针等。 在 C++11 之后，C++ 标准委员会以每三年更新一次的速度向前推进 C++ 标准。
2014 年发布 ISO/IEC 14882:2014，俗称 C++14。 C++14 只是小改动，主要修正 C++11 的错误，增加的功能不多，但包含了读写锁。
2017 年发布 ISO/IEC 14882:2017，俗称 C++17。 C++17 增加了对文件系统的支持。
C++20 在制定中。
`}),e.add({id:1,href:"/study-cpp/docs/basic/grammar/",title:"1.1 语法",section:"第一部分 基础入门",content:` C++ 语法 # main 函数 # int main(int argc, char** argv) { return Envoy::MainCommon::main(argc, argv); } include # 我们使用#include，一般是一下两个目的：
导入 typedef，#define，const 变量等宏配置； 使用在别的 cpp 文件中定义或者静态库定义的函数或者类。 头文件只能声明函数，函数的定义要放到对应的 cpp 文件中，只能 #include 该头文件，而不能 #include 其 cpp 源文件。 #include \u0026quot;\u0026quot; 与 #include \u0026lt;\u0026gt; # 若 #include \u0026quot;\u0026quot; 查找成功，则遮蔽 #include \u0026lt;\u0026gt; 所能找到的同名文件；否则再按照 #include \u0026lt;\u0026gt; 的方式查找文件 一般来说 #include \u0026lt;\u0026gt; 的查找位置是标准库头文件所在目录， #include \u0026quot;\u0026quot; 的查找位置是当前源文件所在目录。不过这些都可由编译器调用参数等配置更改 参考：
C++ #include \u0026quot; \u0026quot; 与 \u0026lt;\u0026gt;有什么区别？ ifndef 与 #pragma once # #ifndef \u0026lt;标识\u0026gt; #define \u0026lt;标识\u0026gt; #endif namespace # 无名命名空间和 static 是同样的道理，都是只在本文件内有效，无法被其它文件引用。 命名空间可以嵌套：abcd::efgh::ijk::A 在通常的编程规范里，严禁在头文件中 using 命名空间 using namespace # 这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称
#include \u0026lt;iostream\u0026gt; using namespace std; // 第一个命名空间 namespace first_space{ void func(){ cout \u0026lt;\u0026lt; \u0026#34;Inside first_space\u0026#34; \u0026lt;\u0026lt; endl; } } // 第二个命名空间 namespace second_space{ void func(){ cout \u0026lt;\u0026lt; \u0026#34;Inside second_space\u0026#34; \u0026lt;\u0026lt; endl; } } using namespace first_space; int main () { // 调用第一个命名空间中的函数 func(); return 0; } `}),e.add({id:2,href:"/study-cpp/docs/basic/grammar/type/",title:"1.1.1 数据类型",section:"1.1 语法",content:" C++ 数据类型 # "}),e.add({id:3,href:"/study-cpp/docs/advanced/pattern/",title:"2.1 设计模式",section:"第二部分 进阶实战",content:" C++ 设计模式 # "}),e.add({id:4,href:"/study-cpp/docs/code/type/",title:"3.1 数据类型",section:"第三部分 设计与实现",content:" C++ 数据类型 # "}),e.add({id:5,href:"/study-cpp/docs/appendix/tutorial/",title:"4.1 教程",section:"第四部分 附录",content:` 教程 # 基础 # learn c++ in y minutes
C++ 后台开发有哪些练基础的开源项目？
yedf/handy 进阶 # 林锐 博士 - 高质量 C++/C 编程指南 `}),e.add({id:6,href:"/study-cpp/docs/basic/grammar/keyword/class/",title:"class",section:"1.1.2 关键字",content:` class # 建议：
class 表示被封装的用户自定义类型，不公开定义非静态数据成员，一般通过成员方法进行交互。 struct 表示数据的简单集合，公开定义数据成员，只定义用于初始化数据成员的方法 (比如：构造 / 析构函数，initialize(), reset(), validate())。 // 简单的数据聚合，没有动作 struct Coordinate { int x; int y; int z; }; // 有动作的对象 class Cat { public: void meow(); private: ... }; class vs struct # 默认继承权限 class: private struct: public 成员的默认访问权限 class: private struct: public 除了这两点，class 和 struct 基本就是一个东西。
`}),e.add({id:7,href:"/study-cpp/docs/basic/grammar/keyword/vs-c/",title:"与 C 的差异",section:"1.1.2 关键字",content:` C++ 与 C 语言的差异 # 字符字面量的大小
// 在C++中，字符字面量的大小是一个字节。 sizeof(\u0026#39;c\u0026#39;) == 1 // 在C语言中，字符字面量的大小与int相同。 sizeof(\u0026#39;c\u0026#39;) == sizeof(10) 函数原型与函数定义匹配
// C++ 的函数原型与函数定义是严格匹配的 void func(); // 这个函数不能接受任何参数 // 而在C语言中 void func(); // 这个函数能接受任意数量的参数 NULL vs nullptr
// 在 C++ 中，用 nullptr 代替 C 语言中的 NULL int* ip = nullptr; 同文件
// C++ 也可以使用 C 语言的标准头文件， // 但是需要加上前缀 “c” 并去掉末尾的 “.h”。 #include \u0026lt;cstdio\u0026gt; `}),e.add({id:8,href:"/study-cpp/docs/basic/grammar/keyword/function/",title:"函数",section:"1.1.2 关键字",content:` 函数 # 函数参数 # 参数默认值
// 你可以为函数的参数指定默认值， // 默认参数必须放在所有的常规参数之后。 void doSomethingWithInts(int a, int b = 1, int c = 4) { } 函数重载 # // C++支持函数重载，你可以定义一组名称相同而参数不同的函数 void print(char const* myString) { printf(\u0026#34;String %s\\n\u0026#34;, myString); } void print(int myInt) { printf(\u0026#34;My int is %d\u0026#34;, myInt); } int main() { print(\u0026#34;Hello\u0026#34;); // 解析为 void print(const char*) print(15); // 解析为 void print(int) } `}),e.add({id:9,href:"/study-cpp/docs/basic/others/practice/",title:"实践",section:"1.4 其他",content:" 实践 # "}),e.add({id:10,href:"/study-cpp/docs/basic/grammar/keyword/pointer/",title:"指针",section:"1.1.2 关键字",content:` C++ 指针 # 智能指针 # 指针类别 支持 备注 unique_ptr C++ 11 拥有独有对象所有权语义的智能指针 shared_ptr C++ 11 拥有共享对象所有权语义的智能指针 weak_ptr C++ 11 到 std::shared_ptr 所管理对象的弱引用 auto_ptr C++ 17 中移除 拥有严格对象所有权语义的智能指针 unique_ptr # std::unique_ptr 是通过指针占有并管理另一对象，并在 unique_ptr 离开作用域时释放该对象的智能指针。在下列两者之一发生时用关联的删除器释放对象：
销毁了管理的 unique_ptr 对象 通过 operator= 或 reset () 赋值另一指针给管理的 unique_ptr 对象。 shared_ptr # std::shared_ptr 是通过指针保持对象共享所有权的智能指针。多个 shared_ptr 对象可占有同一对象。下列情况之一出现时销毁对象并解分配其内存：
最后剩下的占有对象的 shared_ptr 被销毁； 最后剩下的占有对象的 shared_ptr 被通过 operator= 或 reset () 赋值为另一指针。 有两种方式创建 shared_ptr ：
void main( ) { shared_ptr\u0026lt;int\u0026gt; sptr1( new int ); // 使用 make_shared 宏可以加速创建的过程 // 因为 shared_ptr 主动分配内存并且保存引用计数 (reference count) shared_ptr\u0026lt;int\u0026gt; sptr2 = make_shared\u0026lt;int\u0026gt;(100); } 参考：C++ 智能指针 - 内存泄露的惨痛经历
`}),e.add({id:11,href:"/study-cpp/docs/basic/others/standard/",title:"标准",section:"1.4 其他",content:` C++ 标准 # 参考：https://www.cnblogs.com/xuyaowen/p/c-cxx-standards.html
`}),e.add({id:12,href:"/study-cpp/docs/basic/others/version/",title:"版本",section:"1.4 其他",content:" C++ 版本 # "}),e.add({id:13,href:"/study-cpp/docs/basic/grammar/keyword/",title:"1.1.2 关键字",section:"1.1 语法",content:` C++ 关键字 # 这是 C++ 中的保留字列表。因为它们为语言所用，故这些关键词不可用于重定义或重载。
注意 and、bitor、or、xor、compl、bitand、and_eq、or_eq、xor_eq、not 及 not_eq（还有双标符 \u0026lt;%、%\u0026gt;、\u0026lt;:、:\u0026gt;、%: 及 %:%:）提供标准记号的代用表示方法。
参考：C++ 参考手册
`}),e.add({id:14,href:"/study-cpp/docs/basic/std/",title:"1.2 标准库",section:"第一部分 基础入门",content:" C++ 标准库 # "}),e.add({id:15,href:"/study-cpp/docs/advanced/algs/",title:"2.2 算法实现",section:"第二部分 进阶实战",content:" C++ 算法实现 # "}),e.add({id:16,href:"/study-cpp/docs/code/keyword/",title:"3.2 关键字",section:"第三部分 设计与实现",content:" C++ 关键字 # "}),e.add({id:17,href:"/study-cpp/docs/appendix/interview/",title:"4.2 面试题",section:"第四部分 附录",content:` 面试题 # 基础题 # huihut/interview # 你遇到过哪些高质量的 C++ 面试？ # What is the best C++ interview question? [closed] # C++ FAQ # volatile 有什么用？ # 告诉编译器不应对这样的对象进行优化 每次访问时都必须从内存中取出值 没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值 const 可以是 volatile （如只读的状态寄存器） 指针可以是 volatile 进阶题 # 为什么 C++ 的 member function template 不能是 virtual 的 # 比如，下面的代码是不合法的：
class Animal{ public: template\u0026lt;typename T\u0026gt; virtual void make_sound(){ //... } }; 因为 C++ 的编译与链接模型是 \u0026ldquo;分离\u0026rdquo; 的 (至少是部分原因吧)。
从 Unix/C 开始，一个 C/C++ 程序就可以被分开编译，然后用一个 linker 链接起来。这种模型有一个问题，就是各个编译单元可能对另一个编译单元一无所知。 一个 function template 最后到底会被 instantiate 为多少个函数，要等整个程序 (所有的编译单元) 全部被编译完成才知道。 同时，virtual function 的实现大多利用了一个 \u0026ldquo;虚函数表\u0026rdquo; 的东西，这种实现中，一个类的内存布局 (或者说虚函数表的内存布局) 需要在这个类编译完成的时候就被完全确定。 所以，由上面的矛盾可知，C++ 的 member function 不能既是 template 又是 virtual 的。
参考：https://www.zhihu.com/question/60911582/answer/182045051
`}),e.add({id:18,href:"/study-cpp/docs/basic/grammar/keyword/namespace/",title:"命名空间",section:"1.1.2 关键字",content:` C++ 命名空间 # // 命名空间为变量、函数和其他声明提供了分离的的作用域。 // 命名空间可以嵌套使用。 namespace First { namespace Nested { void foo() { printf(\u0026#34;This is First::Nested::foo\\n\u0026#34;); } } // 结束嵌套的命名空间Nested } // 结束命名空间First namespace Second { void foo() { printf(\u0026#34;This is Second::foo\\n\u0026#34;) } } void foo() { printf(\u0026#34;This is global foo\\n\u0026#34;); } int main() { // 如果没有特别指定，就从“Second”中取得所需的内容。 using namespace Second; foo(); // 显示“This is Second::foo” First::Nested::foo(); // 显示“This is First::Nested::foo” ::foo(); // 显示“This is global foo” } `}),e.add({id:19,href:"/study-cpp/docs/basic/grammar/keyword/reference/",title:"引用",section:"1.1.2 关键字",content:` C++ 引用 # 引用是一种特殊的指针类型，一旦被定义就不能重新赋值，并且不能被设置为空值。
使用引用时的语法与原变量相同
对引用类型进行解引用时，不需要使用 * 赋值时也不需要用 \u0026amp; 来取地址 using namespace std; string foo = \u0026#34;I am foo\u0026#34;; string bar = \u0026#34;I am bar\u0026#34;; string\u0026amp; fooRef = foo; // 建立了一个对foo的引用。 fooRef += \u0026#34;. Hi!\u0026#34;; // 通过引用来修改foo的值 cout \u0026lt;\u0026lt; fooRef; // \u0026#34;I am foo. Hi!\u0026#34; // 这句话的并不会改变fooRef的指向，其效果与“foo = bar”相同。 // 也就是说，在执行这条语句之后，foo == \u0026#34;I am bar\u0026#34;。 fooRef = bar; 不能修改一个常量引用的值
const string\u0026amp; barRef = bar; // 建立指向bar的常量引用。 // 和C语言中一样，（指针和引用）声明为常量时，对应的值不能被修改。 barRef += \u0026#34;. Hi!\u0026#34;; // 这是错误的，不能修改一个常量引用的值。 `}),e.add({id:20,href:"/study-cpp/docs/basic/spec/",title:"1.3 编程规范",section:"第一部分 基础入门",content:" C++ 编程规范 # Google C++ Style Guide Google C++ 风格指南 "}),e.add({id:21,href:"/study-cpp/docs/advanced/pkg/",title:"2.3 常用库",section:"第二部分 进阶实战",content:" C++ 常用库 # "}),e.add({id:22,href:"/study-cpp/docs/code/runtime/",title:"3.3 运行时",section:"第三部分 设计与实现",content:" C++ 运行时 # "}),e.add({id:23,href:"/study-cpp/docs/appendix/attention/",title:"4.3 关注项目",section:"第四部分 附录",content:` 关注项目 # google/glog # C++ implementation of the Google logging module
gRPC # gRPC is a modern, open source, high-performance remote procedure call (RPC) framework that can run anywhere. gRPC enables client and server applications to communicate transparently, and simplifies the building of connected systems.
grpc.io
web # ipkn/crow # Crow is very fast and easy to use C++ micro web framework (inspired by Python Flask)
`}),e.add({id:24,href:"/study-cpp/docs/basic/others/",title:"1.4 其他",section:"第一部分 基础入门",content:" 其他 # "}),e.add({id:25,href:"/study-cpp/docs/advanced/snippet/",title:"2.4 代码片段",section:"第二部分 进阶实战",content:" C++ 代码片段 # "}),e.add({id:26,href:"/study-cpp/docs/advanced/test/",title:"2.5 测试",section:"第二部分 进阶实战",content:" C++ 测试 # "}),e.add({id:27,href:"/study-cpp/docs/advanced/prof/",title:"2.6 性能",section:"第二部分 进阶实战",content:" C++ 性能 # "}),e.add({id:28,href:"/study-cpp/docs/advanced/frame/",title:"2.7 框架",section:"第二部分 进阶实战",content:" C++ 框架 # "})})()