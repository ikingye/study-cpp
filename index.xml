<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>首页 on C++ 学习笔记</title><link>https://kingye.me/study-cpp/</link><description>Recent content in 首页 on C++ 学习笔记</description><generator>Hugo</generator><language>en</language><atom:link href="https://kingye.me/study-cpp/index.xml" rel="self" type="application/rss+xml"/><item><title>4.1 教程</title><link>https://kingye.me/study-cpp/docs/appendix/tutorial/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-cpp/docs/appendix/tutorial/</guid><description>&lt;h1 id="教程"&gt;教程&lt;a class="anchor" href="#%e6%95%99%e7%a8%8b"&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;&lt;img src="https://cdn.jsdelivr.net/gh/ikingye/imagehost/picgo/20200611203221.png" alt="" /&gt;&lt;/p&gt;
&lt;h2 id="基础"&gt;基础&lt;a class="anchor" href="#%e5%9f%ba%e7%a1%80"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://learnxinyminutes.com/docs/zh-cn/c&amp;#43;&amp;#43;-cn/"&gt;learn c++ in y minutes&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.zhihu.com/question/39169728"&gt;C++ 后台开发有哪些练基础的开源项目？&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/yedf/handy"&gt;yedf/handy&lt;/a&gt; &lt;img src="https://img.shields.io/github/stars/yedf/handy.svg" alt="Github stars" /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="进阶"&gt;进阶&lt;a class="anchor" href="#%e8%bf%9b%e9%98%b6"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://vrlab.org.cn/~zhuq/download/%E9%AB%98%E8%B4%A8%E9%87%8F%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97.pdf"&gt;林锐 博士 - 高质量 C++/C 编程指南&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>C/C++ 安全规则集合</title><link>https://kingye.me/study-cpp/docs/basic/spec/safe-rules/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-cpp/docs/basic/spec/safe-rules/</guid><description>&lt;p&gt;来源： &lt;a href="https://github.com/Qihoo360/safe-rules"&gt;Qihoo360/safe-rules&lt;/a&gt; &lt;img src="https://img.shields.io/github/stars/Qihoo360/safe-rules.svg" alt="Github stars" /&gt; &lt;img src="https://img.shields.io/github/forks/Qihoo360/safe-rules.svg" alt="Github forks" /&gt; &lt;img src="https://img.shields.io/github/languages/top/Qihoo360/safe-rules.svg" alt="Language" /&gt; &lt;img src="https://img.shields.io/github/v/tag/Qihoo360/safe-rules.svg?sort=semver" alt="Last Tag" /&gt; &lt;img src="https://img.shields.io/github/last-commit/Qihoo360/safe-rules.svg" alt="Last commit" /&gt;&lt;/p&gt;
&lt;h1 id="cc-安全规则集合-version"&gt;C/C++ 安全规则集合 &lt;img src="https://img.shields.io/badge/version-1.3.1-brightgreen" alt="Version" /&gt;&lt;a class="anchor" href="#cc-%e5%ae%89%e5%85%a8%e8%a7%84%e5%88%99%e9%9b%86%e5%90%88-version"&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;blockquote class='book-hint '&gt;
&lt;p&gt;Bjarne Stroustrup: “&lt;em&gt;C makes it easy to shoot yourself in the foot; C++ makes it harder, but when you do it blows your whole leg off.&lt;/em&gt;”&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;  针对 C、C++ 语言，本文收录了 467 种需要重点关注的问题，可为制定编程规范提供依据，也可为代码审计以及相关培训提供指导意见，适用于桌面、服务端以及嵌入式等软件系统。
  每个问题对应一条规则，每条规则可直接作为规范条款或审计检查点，本文是适用于不同应用场景的规则集合，读者可根据自身需求从中选取某个子集作为规范或审计依据，从而提高软件产品的安全性。
&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="规则说明"&gt;规则说明&lt;a class="anchor" href="#%e8%a7%84%e5%88%99%e8%af%b4%e6%98%8e"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;规则按如下主题分为 17 个类别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="#__security"&gt;Security&lt;/a&gt;：敏感信息防护&lt;/li&gt;
&lt;li&gt;&lt;a href="#__resource"&gt;Resource&lt;/a&gt;：资源管理&lt;/li&gt;
&lt;li&gt;&lt;a href="#__precompile"&gt;Precompile&lt;/a&gt;：预处理、宏、注释&lt;/li&gt;
&lt;li&gt;&lt;a href="#__global"&gt;Global&lt;/a&gt;：全局及命名空间作用域&lt;/li&gt;
&lt;li&gt;&lt;a href="#__type"&gt;Type&lt;/a&gt;：类型设计与实现&lt;/li&gt;
&lt;li&gt;&lt;a href="#__declaration"&gt;Declaration&lt;/a&gt;：声明&lt;/li&gt;
&lt;li&gt;&lt;a href="#__exception"&gt;Exception&lt;/a&gt;：异常&lt;/li&gt;
&lt;li&gt;&lt;a href="#__function"&gt;Function&lt;/a&gt;：函数实现&lt;/li&gt;
&lt;li&gt;&lt;a href="#__control"&gt;Control&lt;/a&gt;：流程控制&lt;/li&gt;
&lt;li&gt;&lt;a href="#__expression"&gt;Expression&lt;/a&gt;：表达式&lt;/li&gt;
&lt;li&gt;&lt;a href="#__literal"&gt;Literal&lt;/a&gt;：常量&lt;/li&gt;
&lt;li&gt;&lt;a href="#__cast"&gt;Cast&lt;/a&gt;：类型转换&lt;/li&gt;
&lt;li&gt;&lt;a href="#__buffer"&gt;Buffer&lt;/a&gt;：缓冲区&lt;/li&gt;
&lt;li&gt;&lt;a href="#__pointer"&gt;Pointer&lt;/a&gt;：指针&lt;/li&gt;
&lt;li&gt;&lt;a href="#__interruption"&gt;Interruption&lt;/a&gt;：中断与信号处理&lt;/li&gt;
&lt;li&gt;&lt;a href="#__concurrency"&gt;Concurrency&lt;/a&gt;：异步与并发&lt;/li&gt;
&lt;li&gt;&lt;a href="#__style"&gt;Style&lt;/a&gt;：样式与风格&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;每条规则包括：&lt;/p&gt;</description></item><item><title>class</title><link>https://kingye.me/study-cpp/docs/basic/grammar/keyword/class/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-cpp/docs/basic/grammar/keyword/class/</guid><description>&lt;h1 id="class"&gt;class&lt;a class="anchor" href="#class"&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;建议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;class 表示被封装的用户自定义类型，&lt;strong&gt;不公开定义非静态&lt;/strong&gt;数据成员，一般通过成员方法进行交互。&lt;/li&gt;
&lt;li&gt;struct 表示&lt;strong&gt;数据的简单集合&lt;/strong&gt;，公开定义数据成员，只定义用于初始化数据成员的方法 (比如：构造 / 析构函数，&lt;code&gt;initialize()&lt;/code&gt;, &lt;code&gt;reset()&lt;/code&gt;, &lt;code&gt;validate()&lt;/code&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// 简单的数据聚合，没有动作
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;struct&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;Coordinate&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; x;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; y;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; z;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// 有动作的对象
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;class&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;Cat&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;public&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; meow();
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;private&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; ...
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;};&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="class-vs-struct"&gt;class vs struct&lt;a class="anchor" href="#class-vs-struct"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;默认继承权限
&lt;ul&gt;
&lt;li&gt;class: private&lt;/li&gt;
&lt;li&gt;struct: public&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;成员的默认访问权限
&lt;ul&gt;
&lt;li&gt;class: private&lt;/li&gt;
&lt;li&gt;struct: public&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除了这两点，class 和 struct 基本就是一个东西。&lt;/p&gt;</description></item><item><title>与 C 的差异</title><link>https://kingye.me/study-cpp/docs/basic/grammar/keyword/vs-c/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-cpp/docs/basic/grammar/keyword/vs-c/</guid><description>&lt;h1 id="c-与-c-语言的差异"&gt;C++ 与 C 语言的差异&lt;a class="anchor" href="#c-%e4%b8%8e-c-%e8%af%ad%e8%a8%80%e7%9a%84%e5%b7%ae%e5%bc%82"&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;字符字面量的大小&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// 在C++中，字符字面量的大小是一个字节。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;sizeof&lt;/span&gt;(&lt;span style="color:#e6db74"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;) &lt;span style="color:#f92672"&gt;==&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// 在C语言中，字符字面量的大小与int相同。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;sizeof&lt;/span&gt;(&lt;span style="color:#e6db74"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;) &lt;span style="color:#f92672"&gt;==&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;sizeof&lt;/span&gt;(&lt;span style="color:#ae81ff"&gt;10&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数原型与函数定义匹配&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// C++ 的函数原型与函数定义是严格匹配的
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;func&lt;/span&gt;(); &lt;span style="color:#75715e"&gt;// 这个函数不能接受任何参数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// 而在C语言中
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;func&lt;/span&gt;(); &lt;span style="color:#75715e"&gt;// 这个函数能接受任意数量的参数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;NULL&lt;/code&gt; vs &lt;code&gt;nullptr&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// 在 C++ 中，用 nullptr 代替 C 语言中的 NULL
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;int&lt;/span&gt;&lt;span style="color:#f92672"&gt;*&lt;/span&gt; ip &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;nullptr&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同文件&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// C++ 也可以使用 C 语言的标准头文件，
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// 但是需要加上前缀 “c” 并去掉末尾的 “.h”。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;&lt;span style="color:#75715e"&gt;#include&lt;/span&gt; &lt;span style="color:#75715e"&gt;&amp;lt;cstdio&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>函数</title><link>https://kingye.me/study-cpp/docs/basic/grammar/keyword/function/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-cpp/docs/basic/grammar/keyword/function/</guid><description>&lt;h1 id="函数"&gt;函数&lt;a class="anchor" href="#%e5%87%bd%e6%95%b0"&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;h2 id="函数参数"&gt;函数参数&lt;a class="anchor" href="#%e5%87%bd%e6%95%b0%e5%8f%82%e6%95%b0"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;参数默认值&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// 你可以为函数的参数指定默认值，
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// 默认参数必须放在所有的常规参数之后。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;doSomethingWithInts&lt;/span&gt;(&lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; a, &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; b &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;, &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; c &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;4&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="函数重载"&gt;函数重载&lt;a class="anchor" href="#%e5%87%bd%e6%95%b0%e9%87%8d%e8%bd%bd"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// C++支持函数重载，你可以定义一组名称相同而参数不同的函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;print&lt;/span&gt;(&lt;span style="color:#66d9ef"&gt;char&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;&lt;span style="color:#f92672"&gt;*&lt;/span&gt; myString)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; printf(&lt;span style="color:#e6db74"&gt;&amp;#34;String %s&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;\n&lt;/span&gt;&lt;span style="color:#e6db74"&gt;&amp;#34;&lt;/span&gt;, myString);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;print&lt;/span&gt;(&lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; myInt)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; printf(&lt;span style="color:#e6db74"&gt;&amp;#34;My int is %d&amp;#34;&lt;/span&gt;, myInt);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;main&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; print(&lt;span style="color:#e6db74"&gt;&amp;#34;Hello&amp;#34;&lt;/span&gt;); &lt;span style="color:#75715e"&gt;// 解析为 void print(const char*)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; print(&lt;span style="color:#ae81ff"&gt;15&lt;/span&gt;); &lt;span style="color:#75715e"&gt;// 解析为 void print(int)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description></item><item><title>指针</title><link>https://kingye.me/study-cpp/docs/basic/grammar/keyword/pointer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-cpp/docs/basic/grammar/keyword/pointer/</guid><description>&lt;h1 id="c-指针"&gt;C++ 指针&lt;a class="anchor" href="#c-%e6%8c%87%e9%92%88"&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;h2 id="智能指针"&gt;智能指针&lt;a class="anchor" href="#%e6%99%ba%e8%83%bd%e6%8c%87%e9%92%88"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;指针类别&lt;/th&gt;
 &lt;th&gt;支持&lt;/th&gt;
 &lt;th&gt;备注&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;unique_ptr&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;C++ 11&lt;/td&gt;
 &lt;td&gt;拥有&lt;strong&gt;独有&lt;/strong&gt;对象所有权语义的智能指针&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;shared_ptr&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;C++ 11&lt;/td&gt;
 &lt;td&gt;拥有&lt;strong&gt;共享&lt;/strong&gt;对象所有权语义的智能指针&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;weak_ptr&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;C++ 11&lt;/td&gt;
 &lt;td&gt;到 std::shared_ptr 所管理对象的弱引用&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;auto_ptr&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;C++ 17 中移除&lt;/td&gt;
 &lt;td&gt;拥有严格对象所有权语义的智能指针&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="unique_ptr"&gt;unique_ptr&lt;a class="anchor" href="#unique_ptr"&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;std::unique_ptr 是通过指针占有并管理另一对象，并在 unique_ptr 离开作用域时释放该对象的智能指针。在下列两者之一发生时用关联的删除器释放对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;销毁了管理的 unique_ptr 对象&lt;/li&gt;
&lt;li&gt;通过 operator= 或 reset () 赋值另一指针给管理的 unique_ptr 对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="shared_ptr"&gt;shared_ptr&lt;a class="anchor" href="#shared_ptr"&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;std::shared_ptr 是通过指针保持对象共享所有权的智能指针。多个 shared_ptr 对象可占有同一对象。下列情况之一出现时销毁对象并解分配其内存：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最后剩下的占有对象的 shared_ptr 被销毁；&lt;/li&gt;
&lt;li&gt;最后剩下的占有对象的 shared_ptr 被通过 operator= 或 reset () 赋值为另一指针。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有两种方式创建 &lt;code&gt;shared_ptr&lt;/code&gt; ：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;main&lt;/span&gt;( )
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; shared_ptr&lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;int&lt;/span&gt;&lt;span style="color:#f92672"&gt;&amp;gt;&lt;/span&gt; sptr1( &lt;span style="color:#66d9ef"&gt;new&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; );
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// 使用 make_shared 宏可以加速创建的过程
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; &lt;span style="color:#75715e"&gt;// 因为 shared_ptr 主动分配内存并且保存引用计数 (reference count)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; shared_ptr&lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;int&lt;/span&gt;&lt;span style="color:#f92672"&gt;&amp;gt;&lt;/span&gt; sptr2 &lt;span style="color:#f92672"&gt;=&lt;/span&gt; make_shared&lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;int&lt;/span&gt;&lt;span style="color:#f92672"&gt;&amp;gt;&lt;/span&gt;(&lt;span style="color:#ae81ff"&gt;100&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;参考：&lt;a href="https://blog.csdn.net/jcq521045349/article/details/88957222"&gt;C++ 智能指针 - 内存泄露的惨痛经历&lt;/a&gt;&lt;/p&gt;</description></item><item><title>版本</title><link>https://kingye.me/study-cpp/docs/basic/others/version/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-cpp/docs/basic/others/version/</guid><description>&lt;h1 id="c-版本"&gt;C++ 版本&lt;a class="anchor" href="#c-%e7%89%88%e6%9c%ac"&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;h2 id="c-reference"&gt;&lt;a href="https://en.cppreference.com/w/cpp"&gt;C++ reference&lt;/a&gt;&lt;a class="anchor" href="#c-reference"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="c23"&gt;C++23&lt;a class="anchor" href="#c23"&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;hr&gt;
&lt;h3 id="c20"&gt;C++20&lt;a class="anchor" href="#c20"&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;hr&gt;
&lt;h3 id="c17"&gt;C++17&lt;a class="anchor" href="#c17"&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;hr&gt;
&lt;h3 id="c14"&gt;C++14&lt;a class="anchor" href="#c14"&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;hr&gt;
&lt;h3 id="c11"&gt;C++11&lt;a class="anchor" href="#c11"&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;hr&gt;
&lt;h3 id="c03"&gt;C++03&lt;a class="anchor" href="#c03"&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;hr&gt;
&lt;h3 id="c98"&gt;C++98&lt;a class="anchor" href="#c98"&gt;#&lt;/a&gt;&lt;/h3&gt;</description></item><item><title>4.2 面试题</title><link>https://kingye.me/study-cpp/docs/appendix/interview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-cpp/docs/appendix/interview/</guid><description>&lt;h1 id="面试题"&gt;面试题&lt;a class="anchor" href="#%e9%9d%a2%e8%af%95%e9%a2%98"&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;h2 id="基础题"&gt;基础题&lt;a class="anchor" href="#%e5%9f%ba%e7%a1%80%e9%a2%98"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="huihutinterview-github-stars"&gt;&lt;a href="https://github.com/huihut/interview"&gt;huihut/interview&lt;/a&gt; &lt;img src="https://img.shields.io/github/stars/huihut/interview.svg" alt="Github stars" /&gt;&lt;a class="anchor" href="#huihutinterview-github-stars"&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id="你遇到过哪些高质量的-c-面试"&gt;&lt;a href="https://www.zhihu.com/question/60911582"&gt;你遇到过哪些高质量的 C++ 面试？&lt;/a&gt;&lt;a class="anchor" href="#%e4%bd%a0%e9%81%87%e5%88%b0%e8%bf%87%e5%93%aa%e4%ba%9b%e9%ab%98%e8%b4%a8%e9%87%8f%e7%9a%84-c-%e9%9d%a2%e8%af%95"&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id="what-is-the-best-c-interview-question-"&gt;&lt;a href="https://softwareengineering.stackexchange.com/questions/25836/what-is-the-best-c-interview-question"&gt;What is the best C++ interview question? [closed]&lt;/a&gt;&lt;a class="anchor" href="#what-is-the-best-c-interview-question-"&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id="c-faq"&gt;&lt;a href="http://www.cs.technion.ac.il/users/yechiel/c&amp;#43;&amp;#43;-faq/index.html"&gt;C++ FAQ&lt;/a&gt;&lt;a class="anchor" href="#c-faq"&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;hr&gt;
&lt;h3 id="volatile-有什么用"&gt;volatile 有什么用？&lt;a class="anchor" href="#volatile-%e6%9c%89%e4%bb%80%e4%b9%88%e7%94%a8"&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;告诉编译器不应对这样的对象进行优化&lt;/li&gt;
&lt;li&gt;每次访问时都必须从内存中取出值
&lt;ul&gt;
&lt;li&gt;没有被 volatile 修饰的变量，可能由于编译器的优化，从 &lt;strong&gt;CPU 寄存器&lt;/strong&gt;中取值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;const 可以是 volatile （如只读的状态寄存器）&lt;/li&gt;
&lt;li&gt;指针可以是 volatile&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;hr&gt;
&lt;h2 id="进阶题"&gt;进阶题&lt;a class="anchor" href="#%e8%bf%9b%e9%98%b6%e9%a2%98"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="为什么-c-的-member-function-template-不能是-virtual-的"&gt;为什么 C++ 的 member function template 不能是 virtual 的&lt;a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88-c-%e7%9a%84-member-function-template-%e4%b8%8d%e8%83%bd%e6%98%af-virtual-%e7%9a%84"&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;比如，下面的代码是不合法的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;class&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;Animal&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;public&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;template&lt;/span&gt;&lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;typename&lt;/span&gt; T&lt;span style="color:#f92672"&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;virtual&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; make_sound(){
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;//...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;};&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;因为 C++ 的编译与链接模型是 &amp;ldquo;分离&amp;rdquo; 的 (至少是部分原因吧)。&lt;/p&gt;
&lt;p&gt;从 Unix/C 开始，一个 C/C++ 程序就可以被分开编译，然后用一个 linker 链接起来。这种模型有一个问题，就是各个编译单元可能对另一个编译单元一无所知。
一个 function template 最后到底会被 instantiate 为多少个函数，要等整个程序 (所有的编译单元) 全部被编译完成才知道。
同时，virtual function 的实现大多利用了一个 &amp;ldquo;虚函数表&amp;rdquo; 的东西，这种实现中，一个类的内存布局 (或者说虚函数表的内存布局) 需要在这个类编译完成的时候就被完全确定。
所以，由上面的矛盾可知，C++ 的 member function 不能既是 template 又是 virtual 的。&lt;/p&gt;</description></item><item><title>命名空间</title><link>https://kingye.me/study-cpp/docs/basic/grammar/keyword/namespace/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-cpp/docs/basic/grammar/keyword/namespace/</guid><description>&lt;h1 id="c-命名空间"&gt;C++ 命名空间&lt;a class="anchor" href="#c-%e5%91%bd%e5%90%8d%e7%a9%ba%e9%97%b4"&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// 命名空间为变量、函数和其他声明提供了分离的的作用域。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// 命名空间可以嵌套使用。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;namespace&lt;/span&gt; First {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;namespace&lt;/span&gt; Nested {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;foo&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; printf(&lt;span style="color:#e6db74"&gt;&amp;#34;This is First::Nested::foo&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;\n&lt;/span&gt;&lt;span style="color:#e6db74"&gt;&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; } &lt;span style="color:#75715e"&gt;// 结束嵌套的命名空间Nested
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;} &lt;span style="color:#75715e"&gt;// 结束命名空间First
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;namespace&lt;/span&gt; Second {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;foo&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; printf(&lt;span style="color:#e6db74"&gt;&amp;#34;This is Second::foo&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;\n&lt;/span&gt;&lt;span style="color:#e6db74"&gt;&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;foo&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; printf(&lt;span style="color:#e6db74"&gt;&amp;#34;This is global foo&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;\n&lt;/span&gt;&lt;span style="color:#e6db74"&gt;&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;main&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// 如果没有特别指定，就从“Second”中取得所需的内容。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;using&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;namespace&lt;/span&gt; Second;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; foo(); &lt;span style="color:#75715e"&gt;// 显示“This is Second::foo”
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; First&lt;span style="color:#f92672"&gt;::&lt;/span&gt;Nested&lt;span style="color:#f92672"&gt;::&lt;/span&gt;foo(); &lt;span style="color:#75715e"&gt;// 显示“This is First::Nested::foo”
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; &lt;span style="color:#f92672"&gt;::&lt;/span&gt;foo(); &lt;span style="color:#75715e"&gt;// 显示“This is global foo”
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description></item><item><title>引用</title><link>https://kingye.me/study-cpp/docs/basic/grammar/keyword/reference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-cpp/docs/basic/grammar/keyword/reference/</guid><description>&lt;h1 id="c-引用"&gt;C++ 引用&lt;a class="anchor" href="#c-%e5%bc%95%e7%94%a8"&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;引用是一种特殊的指针类型，一旦被定义就不能重新赋值，并且不能被设置为空值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用引用时的语法与原变量相同&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对引用类型进行解引用时，不需要使用 &lt;code&gt;*&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;赋值时也不需要用 &lt;code&gt;&amp;amp;&lt;/code&gt; 来取地址&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;using&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;namespace&lt;/span&gt; std;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;string foo &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#e6db74"&gt;&amp;#34;I am foo&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;string bar &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#e6db74"&gt;&amp;#34;I am bar&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;string&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt; fooRef &lt;span style="color:#f92672"&gt;=&lt;/span&gt; foo; &lt;span style="color:#75715e"&gt;// 建立了一个对foo的引用。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;fooRef &lt;span style="color:#f92672"&gt;+=&lt;/span&gt; &lt;span style="color:#e6db74"&gt;&amp;#34;. Hi!&amp;#34;&lt;/span&gt;; &lt;span style="color:#75715e"&gt;// 通过引用来修改foo的值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;cout &lt;span style="color:#f92672"&gt;&amp;lt;&amp;lt;&lt;/span&gt; fooRef; &lt;span style="color:#75715e"&gt;// &amp;#34;I am foo. Hi!&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// 这句话的并不会改变fooRef的指向，其效果与“foo = bar”相同。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// 也就是说，在执行这条语句之后，foo == &amp;#34;I am bar&amp;#34;。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;fooRef &lt;span style="color:#f92672"&gt;=&lt;/span&gt; bar;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不能修改一个常量引用的值&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; string&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt; barRef &lt;span style="color:#f92672"&gt;=&lt;/span&gt; bar; &lt;span style="color:#75715e"&gt;// 建立指向bar的常量引用。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// 和C语言中一样，（指针和引用）声明为常量时，对应的值不能被修改。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;barRef &lt;span style="color:#f92672"&gt;+=&lt;/span&gt; &lt;span style="color:#e6db74"&gt;&amp;#34;. Hi!&amp;#34;&lt;/span&gt;; &lt;span style="color:#75715e"&gt;// 这是错误的，不能修改一个常量引用的值。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>4.3 关注项目</title><link>https://kingye.me/study-cpp/docs/appendix/attention/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-cpp/docs/appendix/attention/</guid><description>&lt;h1 id="关注项目"&gt;关注项目&lt;a class="anchor" href="#%e5%85%b3%e6%b3%a8%e9%a1%b9%e7%9b%ae"&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;h2 id="googleglog-github-stars"&gt;&lt;a href="https://github.com/google/glog"&gt;google/glog&lt;/a&gt; &lt;img src="https://img.shields.io/github/stars/google/glog.svg" alt="Github stars" /&gt;&lt;a class="anchor" href="#googleglog-github-stars"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;C++ implementation of the Google logging module&lt;/p&gt;
&lt;h2 id="grpc-github-stars"&gt;&lt;a href="https://github.com/grpc/grpc"&gt;gRPC&lt;/a&gt; &lt;img src="https://img.shields.io/github/stars/grpc/grpc.svg" alt="Github stars" /&gt;&lt;a class="anchor" href="#grpc-github-stars"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;gRPC is a modern, open source, high-performance remote procedure call (RPC) framework that can run anywhere. gRPC enables client and server applications to communicate transparently, and simplifies the building of connected systems.&lt;/p&gt;
&lt;p&gt;grpc.io&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="web"&gt;web&lt;a class="anchor" href="#web"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="ipkncrow-github-stars"&gt;&lt;a href="https://github.com/ipkn/crow"&gt;ipkn/crow&lt;/a&gt; &lt;img src="https://img.shields.io/github/stars/ipkn/crow.svg" alt="Github stars" /&gt;&lt;a class="anchor" href="#ipkncrow-github-stars"&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Crow is very fast and easy to use C++ micro web framework (inspired by Python Flask)&lt;/p&gt;</description></item></channel></rss>