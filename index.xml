<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>首页 on C++ 学习笔记</title><link>https://kingye.me/study-cpp/</link><description>Recent content in 首页 on C++ 学习笔记</description><generator>Hugo</generator><language>en</language><atom:link href="https://kingye.me/study-cpp/index.xml" rel="self" type="application/rss+xml"/><item><title>4.1 教程</title><link>https://kingye.me/study-cpp/docs/appendix/tutorial/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-cpp/docs/appendix/tutorial/</guid><description>&lt;h1 id="教程">
 教程
 &lt;a class="anchor" href="#%e6%95%99%e7%a8%8b">#&lt;/a>
&lt;/h1>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/ikingye/imagehost/picgo/20200611203221.png" alt="" />&lt;/p>
&lt;h2 id="基础">
 基础
 &lt;a class="anchor" href="#%e5%9f%ba%e7%a1%80">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://learnxinyminutes.com/docs/zh-cn/c&amp;#43;&amp;#43;-cn/">learn c++ in y minutes&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.zhihu.com/question/39169728">C++ 后台开发有哪些练基础的开源项目？&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/yedf/handy">yedf/handy&lt;/a> &lt;img src="https://img.shields.io/github/stars/yedf/handy.svg" alt="Github stars" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="进阶">
 进阶
 &lt;a class="anchor" href="#%e8%bf%9b%e9%98%b6">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://vrlab.org.cn/~zhuq/download/%E9%AB%98%E8%B4%A8%E9%87%8F%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97.pdf">林锐 博士 - 高质量 C++/C 编程指南&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>C/C++ 安全规则集合</title><link>https://kingye.me/study-cpp/docs/basic/spec/safe-rules/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-cpp/docs/basic/spec/safe-rules/</guid><description>&lt;p>来源： &lt;a href="https://github.com/Qihoo360/safe-rules">Qihoo360/safe-rules&lt;/a> &lt;img src="https://img.shields.io/github/stars/Qihoo360/safe-rules.svg" alt="Github stars" /> &lt;img src="https://img.shields.io/github/forks/Qihoo360/safe-rules.svg" alt="Github forks" /> &lt;img src="https://img.shields.io/github/languages/top/Qihoo360/safe-rules.svg" alt="Language" /> &lt;img src="https://img.shields.io/github/v/tag/Qihoo360/safe-rules.svg?sort=semver" alt="Last Tag" /> &lt;img src="https://img.shields.io/github/last-commit/Qihoo360/safe-rules.svg" alt="Last commit" />&lt;/p>
&lt;h1 id="cc-安全规则集合-versionhttpsimgshieldsiobadgeversion-131-brightgreen">
 C/C++ 安全规则集合 &lt;img src="https://img.shields.io/badge/version-1.3.1-brightgreen" alt="Version" />
 &lt;a class="anchor" href="#cc-%e5%ae%89%e5%85%a8%e8%a7%84%e5%88%99%e9%9b%86%e5%90%88-versionhttpsimgshieldsiobadgeversion-131-brightgreen">#&lt;/a>
&lt;/h1>
&lt;blockquote>
&lt;p>Bjarne Stroustrup: “&lt;em>C makes it easy to shoot yourself in the foot; C++ makes it harder, but when you do it blows your whole leg off.&lt;/em>”&lt;/p>
&lt;/blockquote>
&lt;p>  针对 C、C++ 语言，本文收录了 467 种需要重点关注的问题，可为制定编程规范提供依据，也可为代码审计以及相关培训提供指导意见，适用于桌面、服务端以及嵌入式等软件系统。
  每个问题对应一条规则，每条规则可直接作为规范条款或审计检查点，本文是适用于不同应用场景的规则集合，读者可根据自身需求从中选取某个子集作为规范或审计依据，从而提高软件产品的安全性。
&lt;br/>&lt;/p>
&lt;h2 id="规则说明">
 规则说明
 &lt;a class="anchor" href="#%e8%a7%84%e5%88%99%e8%af%b4%e6%98%8e">#&lt;/a>
&lt;/h2>
&lt;p>规则按如下主题分为 17 个类别：&lt;/p>
&lt;ol>
&lt;li>&lt;a href="#__security">Security&lt;/a>：敏感信息防护&lt;/li>
&lt;li>&lt;a href="#__resource">Resource&lt;/a>：资源管理&lt;/li>
&lt;li>&lt;a href="#__precompile">Precompile&lt;/a>：预处理、宏、注释&lt;/li>
&lt;li>&lt;a href="#__global">Global&lt;/a>：全局及命名空间作用域&lt;/li>
&lt;li>&lt;a href="#__type">Type&lt;/a>：类型设计与实现&lt;/li>
&lt;li>&lt;a href="#__declaration">Declaration&lt;/a>：声明&lt;/li>
&lt;li>&lt;a href="#__exception">Exception&lt;/a>：异常&lt;/li>
&lt;li>&lt;a href="#__function">Function&lt;/a>：函数实现&lt;/li>
&lt;li>&lt;a href="#__control">Control&lt;/a>：流程控制&lt;/li>
&lt;li>&lt;a href="#__expression">Expression&lt;/a>：表达式&lt;/li>
&lt;li>&lt;a href="#__literal">Literal&lt;/a>：常量&lt;/li>
&lt;li>&lt;a href="#__cast">Cast&lt;/a>：类型转换&lt;/li>
&lt;li>&lt;a href="#__buffer">Buffer&lt;/a>：缓冲区&lt;/li>
&lt;li>&lt;a href="#__pointer">Pointer&lt;/a>：指针&lt;/li>
&lt;li>&lt;a href="#__interruption">Interruption&lt;/a>：中断与信号处理&lt;/li>
&lt;li>&lt;a href="#__concurrency">Concurrency&lt;/a>：异步与并发&lt;/li>
&lt;li>&lt;a href="#__style">Style&lt;/a>：样式与风格&lt;/li>
&lt;/ol>
&lt;p>每条规则包括：&lt;/p></description></item><item><title>class</title><link>https://kingye.me/study-cpp/docs/basic/grammar/keyword/class/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-cpp/docs/basic/grammar/keyword/class/</guid><description>&lt;h1 id="class">
 class
 &lt;a class="anchor" href="#class">#&lt;/a>
&lt;/h1>
&lt;p>建议：&lt;/p>
&lt;ul>
&lt;li>class 表示被封装的用户自定义类型，&lt;strong>不公开定义非静态&lt;/strong>数据成员，一般通过成员方法进行交互。&lt;/li>
&lt;li>struct 表示&lt;strong>数据的简单集合&lt;/strong>，公开定义数据成员，只定义用于初始化数据成员的方法 (比如：构造 / 析构函数，&lt;code>initialize()&lt;/code>, &lt;code>reset()&lt;/code>, &lt;code>validate()&lt;/code>)。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 简单的数据聚合，没有动作
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Coordinate&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> y;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> z;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 有动作的对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Cat&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> meow();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="class-vs-struct">
 class vs struct
 &lt;a class="anchor" href="#class-vs-struct">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>默认继承权限
&lt;ul>
&lt;li>class: private&lt;/li>
&lt;li>struct: public&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>成员的默认访问权限
&lt;ul>
&lt;li>class: private&lt;/li>
&lt;li>struct: public&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>除了这两点，class 和 struct 基本就是一个东西。&lt;/p></description></item><item><title>与 C 的差异</title><link>https://kingye.me/study-cpp/docs/basic/grammar/keyword/vs-c/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-cpp/docs/basic/grammar/keyword/vs-c/</guid><description>&lt;h1 id="c-与-c-语言的差异">
 C++ 与 C 语言的差异
 &lt;a class="anchor" href="#c-%e4%b8%8e-c-%e8%af%ad%e8%a8%80%e7%9a%84%e5%b7%ae%e5%bc%82">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>字符字面量的大小&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 在C++中，字符字面量的大小是一个字节。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;c&amp;#39;&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 在C语言中，字符字面量的大小与int相同。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;c&amp;#39;&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#ae81ff">10&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>函数原型与函数定义匹配&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// C++ 的函数原型与函数定义是严格匹配的
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">func&lt;/span>(); &lt;span style="color:#75715e">// 这个函数不能接受任何参数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 而在C语言中
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">func&lt;/span>(); &lt;span style="color:#75715e">// 这个函数能接受任意数量的参数
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;code>NULL&lt;/code> vs &lt;code>nullptr&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 在 C++ 中，用 nullptr 代替 C 语言中的 NULL
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">*&lt;/span> ip &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">nullptr&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>同文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// C++ 也可以使用 C 语言的标准头文件，
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 但是需要加上前缀 “c” 并去掉末尾的 “.h”。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul></description></item><item><title>函数</title><link>https://kingye.me/study-cpp/docs/basic/grammar/keyword/function/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-cpp/docs/basic/grammar/keyword/function/</guid><description>&lt;h1 id="函数">
 函数
 &lt;a class="anchor" href="#%e5%87%bd%e6%95%b0">#&lt;/a>
&lt;/h1>
&lt;h2 id="函数参数">
 函数参数
 &lt;a class="anchor" href="#%e5%87%bd%e6%95%b0%e5%8f%82%e6%95%b0">#&lt;/a>
&lt;/h2>
&lt;p>参数默认值&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 你可以为函数的参数指定默认值，
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 默认参数必须放在所有的常规参数之后。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">doSomethingWithInts&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> a, &lt;span style="color:#66d9ef">int&lt;/span> b &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#66d9ef">int&lt;/span> c &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="函数重载">
 函数重载
 &lt;a class="anchor" href="#%e5%87%bd%e6%95%b0%e9%87%8d%e8%bd%bd">#&lt;/a>
&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// C++支持函数重载，你可以定义一组名称相同而参数不同的函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">print&lt;/span>(&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span>&lt;span style="color:#f92672">*&lt;/span> myString)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;String %s&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, myString);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">print&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> myInt)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;My int is %d&amp;#34;&lt;/span>, myInt);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="color:#e6db74">&amp;#34;Hello&amp;#34;&lt;/span>); &lt;span style="color:#75715e">// 解析为 void print(const char*)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> print(&lt;span style="color:#ae81ff">15&lt;/span>); &lt;span style="color:#75715e">// 解析为 void print(int)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>指针</title><link>https://kingye.me/study-cpp/docs/basic/grammar/keyword/pointer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-cpp/docs/basic/grammar/keyword/pointer/</guid><description>&lt;h1 id="c-指针">
 C++ 指针
 &lt;a class="anchor" href="#c-%e6%8c%87%e9%92%88">#&lt;/a>
&lt;/h1>
&lt;h2 id="智能指针">
 智能指针
 &lt;a class="anchor" href="#%e6%99%ba%e8%83%bd%e6%8c%87%e9%92%88">#&lt;/a>
&lt;/h2>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>指针类别&lt;/th>
 &lt;th>支持&lt;/th>
 &lt;th>备注&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>&lt;code>unique_ptr&lt;/code>&lt;/td>
 &lt;td>C++ 11&lt;/td>
 &lt;td>拥有&lt;strong>独有&lt;/strong>对象所有权语义的智能指针&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;code>shared_ptr&lt;/code>&lt;/td>
 &lt;td>C++ 11&lt;/td>
 &lt;td>拥有&lt;strong>共享&lt;/strong>对象所有权语义的智能指针&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;code>weak_ptr&lt;/code>&lt;/td>
 &lt;td>C++ 11&lt;/td>
 &lt;td>到 std::shared_ptr 所管理对象的弱引用&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;code>auto_ptr&lt;/code>&lt;/td>
 &lt;td>C++ 17 中移除&lt;/td>
 &lt;td>拥有严格对象所有权语义的智能指针&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;h3 id="unique_ptr">
 unique_ptr
 &lt;a class="anchor" href="#unique_ptr">#&lt;/a>
&lt;/h3>
&lt;p>std::unique_ptr 是通过指针占有并管理另一对象，并在 unique_ptr 离开作用域时释放该对象的智能指针。在下列两者之一发生时用关联的删除器释放对象：&lt;/p>
&lt;ul>
&lt;li>销毁了管理的 unique_ptr 对象&lt;/li>
&lt;li>通过 operator= 或 reset () 赋值另一指针给管理的 unique_ptr 对象。&lt;/li>
&lt;/ul>
&lt;h3 id="shared_ptr">
 shared_ptr
 &lt;a class="anchor" href="#shared_ptr">#&lt;/a>
&lt;/h3>
&lt;p>std::shared_ptr 是通过指针保持对象共享所有权的智能指针。多个 shared_ptr 对象可占有同一对象。下列情况之一出现时销毁对象并解分配其内存：&lt;/p>
&lt;ul>
&lt;li>最后剩下的占有对象的 shared_ptr 被销毁；&lt;/li>
&lt;li>最后剩下的占有对象的 shared_ptr 被通过 operator= 或 reset () 赋值为另一指针。&lt;/li>
&lt;/ul>
&lt;p>有两种方式创建 &lt;code>shared_ptr&lt;/code> ：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>( )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> shared_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> sptr1( &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> );
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用 make_shared 宏可以加速创建的过程
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 因为 shared_ptr 主动分配内存并且保存引用计数 (reference count)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> shared_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> sptr2 &lt;span style="color:#f92672">=&lt;/span> make_shared&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>(&lt;span style="color:#ae81ff">100&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>参考：&lt;a href="https://blog.csdn.net/jcq521045349/article/details/88957222">C++ 智能指针 - 内存泄露的惨痛经历&lt;/a>&lt;/p></description></item><item><title>版本</title><link>https://kingye.me/study-cpp/docs/basic/others/version/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-cpp/docs/basic/others/version/</guid><description>&lt;h1 id="c-版本">
 C++ 版本
 &lt;a class="anchor" href="#c-%e7%89%88%e6%9c%ac">#&lt;/a>
&lt;/h1>
&lt;h2 id="c-referencehttpsencppreferencecomwcpp">
 &lt;a href="https://en.cppreference.com/w/cpp">C++ reference&lt;/a>
 &lt;a class="anchor" href="#c-referencehttpsencppreferencecomwcpp">#&lt;/a>
&lt;/h2>
&lt;h3 id="c23">
 C++23
 &lt;a class="anchor" href="#c23">#&lt;/a>
&lt;/h3>
&lt;hr>
&lt;h3 id="c20">
 C++20
 &lt;a class="anchor" href="#c20">#&lt;/a>
&lt;/h3>
&lt;hr>
&lt;h3 id="c17">
 C++17
 &lt;a class="anchor" href="#c17">#&lt;/a>
&lt;/h3>
&lt;hr>
&lt;h3 id="c14">
 C++14
 &lt;a class="anchor" href="#c14">#&lt;/a>
&lt;/h3>
&lt;hr>
&lt;h3 id="c11">
 C++11
 &lt;a class="anchor" href="#c11">#&lt;/a>
&lt;/h3>
&lt;hr>
&lt;h3 id="c03">
 C++03
 &lt;a class="anchor" href="#c03">#&lt;/a>
&lt;/h3>
&lt;hr>
&lt;h3 id="c98">
 C++98
 &lt;a class="anchor" href="#c98">#&lt;/a>
&lt;/h3></description></item><item><title>4.2 面试题</title><link>https://kingye.me/study-cpp/docs/appendix/interview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-cpp/docs/appendix/interview/</guid><description>&lt;h1 id="面试题">
 面试题
 &lt;a class="anchor" href="#%e9%9d%a2%e8%af%95%e9%a2%98">#&lt;/a>
&lt;/h1>
&lt;h2 id="基础题">
 基础题
 &lt;a class="anchor" href="#%e5%9f%ba%e7%a1%80%e9%a2%98">#&lt;/a>
&lt;/h2>
&lt;h3 id="huihutinterviewhttpsgithubcomhuihutinterview-github-starshttpsimgshieldsiogithubstarshuihutinterviewsvg">
 &lt;a href="https://github.com/huihut/interview">huihut/interview&lt;/a> &lt;img src="https://img.shields.io/github/stars/huihut/interview.svg" alt="Github stars" />
 &lt;a class="anchor" href="#huihutinterviewhttpsgithubcomhuihutinterview-github-starshttpsimgshieldsiogithubstarshuihutinterviewsvg">#&lt;/a>
&lt;/h3>
&lt;h3 id="你遇到过哪些高质量的-c-面试httpswwwzhihucomquestion60911582">
 &lt;a href="https://www.zhihu.com/question/60911582">你遇到过哪些高质量的 C++ 面试？&lt;/a>
 &lt;a class="anchor" href="#%e4%bd%a0%e9%81%87%e5%88%b0%e8%bf%87%e5%93%aa%e4%ba%9b%e9%ab%98%e8%b4%a8%e9%87%8f%e7%9a%84-c-%e9%9d%a2%e8%af%95httpswwwzhihucomquestion60911582">#&lt;/a>
&lt;/h3>
&lt;h3 id="what-is-the-best-c-interview-question-closedhttpssoftwareengineeringstackexchangecomquestions25836what-is-the-best-c-interview-question">
 &lt;a href="https://softwareengineering.stackexchange.com/questions/25836/what-is-the-best-c-interview-question">What is the best C++ interview question? [closed]&lt;/a>
 &lt;a class="anchor" href="#what-is-the-best-c-interview-question-closedhttpssoftwareengineeringstackexchangecomquestions25836what-is-the-best-c-interview-question">#&lt;/a>
&lt;/h3>
&lt;h3 id="c-faqhttpwwwcstechnionacilusersyechielc-faqindexhtml">
 &lt;a href="http://www.cs.technion.ac.il/users/yechiel/c&amp;#43;&amp;#43;-faq/index.html">C++ FAQ&lt;/a>
 &lt;a class="anchor" href="#c-faqhttpwwwcstechnionacilusersyechielc-faqindexhtml">#&lt;/a>
&lt;/h3>
&lt;hr>
&lt;h3 id="volatile-有什么用">
 volatile 有什么用？
 &lt;a class="anchor" href="#volatile-%e6%9c%89%e4%bb%80%e4%b9%88%e7%94%a8">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>告诉编译器不应对这样的对象进行优化&lt;/li>
&lt;li>每次访问时都必须从内存中取出值
&lt;ul>
&lt;li>没有被 volatile 修饰的变量，可能由于编译器的优化，从 &lt;strong>CPU 寄存器&lt;/strong>中取值&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>const 可以是 volatile （如只读的状态寄存器）&lt;/li>
&lt;li>指针可以是 volatile&lt;/li>
&lt;/ul>
&lt;hr>
&lt;hr>
&lt;h2 id="进阶题">
 进阶题
 &lt;a class="anchor" href="#%e8%bf%9b%e9%98%b6%e9%a2%98">#&lt;/a>
&lt;/h2>
&lt;h3 id="为什么-c-的-member-function-template-不能是-virtual-的">
 为什么 C++ 的 member function template 不能是 virtual 的
 &lt;a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88-c-%e7%9a%84-member-function-template-%e4%b8%8d%e8%83%bd%e6%98%af-virtual-%e7%9a%84">#&lt;/a>
&lt;/h3>
&lt;p>比如，下面的代码是不合法的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Animal&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">template&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> make_sound(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>因为 C++ 的编译与链接模型是 &amp;ldquo;分离&amp;rdquo; 的 (至少是部分原因吧)。&lt;/p></description></item><item><title>命名空间</title><link>https://kingye.me/study-cpp/docs/basic/grammar/keyword/namespace/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-cpp/docs/basic/grammar/keyword/namespace/</guid><description>&lt;h1 id="c-命名空间">
 C++ 命名空间
 &lt;a class="anchor" href="#c-%e5%91%bd%e5%90%8d%e7%a9%ba%e9%97%b4">#&lt;/a>
&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 命名空间为变量、函数和其他声明提供了分离的的作用域。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 命名空间可以嵌套使用。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">namespace&lt;/span> First {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">namespace&lt;/span> Nested {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">foo&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;This is First::Nested::foo&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#75715e">// 结束嵌套的命名空间Nested
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>} &lt;span style="color:#75715e">// 结束命名空间First
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">namespace&lt;/span> Second {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">foo&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;This is Second::foo&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">foo&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;This is global foo&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 如果没有特别指定，就从“Second”中取得所需的内容。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> Second;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> foo(); &lt;span style="color:#75715e">// 显示“This is Second::foo”
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> First&lt;span style="color:#f92672">::&lt;/span>Nested&lt;span style="color:#f92672">::&lt;/span>foo(); &lt;span style="color:#75715e">// 显示“This is First::Nested::foo”
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">::&lt;/span>foo(); &lt;span style="color:#75715e">// 显示“This is global foo”
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>引用</title><link>https://kingye.me/study-cpp/docs/basic/grammar/keyword/reference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-cpp/docs/basic/grammar/keyword/reference/</guid><description>&lt;h1 id="c-引用">
 C++ 引用
 &lt;a class="anchor" href="#c-%e5%bc%95%e7%94%a8">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>引用是一种特殊的指针类型，一旦被定义就不能重新赋值，并且不能被设置为空值。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用引用时的语法与原变量相同&lt;/p>
&lt;ul>
&lt;li>对引用类型进行解引用时，不需要使用 &lt;code>*&lt;/code>&lt;/li>
&lt;li>赋值时也不需要用 &lt;code>&amp;amp;&lt;/code> 来取地址&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>string foo &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;I am foo&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>string bar &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;I am bar&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>string&lt;span style="color:#f92672">&amp;amp;&lt;/span> fooRef &lt;span style="color:#f92672">=&lt;/span> foo; &lt;span style="color:#75715e">// 建立了一个对foo的引用。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>fooRef &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;. Hi!&amp;#34;&lt;/span>; &lt;span style="color:#75715e">// 通过引用来修改foo的值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> fooRef; &lt;span style="color:#75715e">// &amp;#34;I am foo. Hi!&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 这句话的并不会改变fooRef的指向，其效果与“foo = bar”相同。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 也就是说，在执行这条语句之后，foo == &amp;#34;I am bar&amp;#34;。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>fooRef &lt;span style="color:#f92672">=&lt;/span> bar;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>不能修改一个常量引用的值&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> string&lt;span style="color:#f92672">&amp;amp;&lt;/span> barRef &lt;span style="color:#f92672">=&lt;/span> bar; &lt;span style="color:#75715e">// 建立指向bar的常量引用。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 和C语言中一样，（指针和引用）声明为常量时，对应的值不能被修改。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>barRef &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;. Hi!&amp;#34;&lt;/span>; &lt;span style="color:#75715e">// 这是错误的，不能修改一个常量引用的值。
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul></description></item><item><title>4.3 关注项目</title><link>https://kingye.me/study-cpp/docs/appendix/attention/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-cpp/docs/appendix/attention/</guid><description>&lt;h1 id="关注项目">
 关注项目
 &lt;a class="anchor" href="#%e5%85%b3%e6%b3%a8%e9%a1%b9%e7%9b%ae">#&lt;/a>
&lt;/h1>
&lt;h2 id="googlegloghttpsgithubcomgoogleglog-github-starshttpsimgshieldsiogithubstarsgoogleglogsvg">
 &lt;a href="https://github.com/google/glog">google/glog&lt;/a> &lt;img src="https://img.shields.io/github/stars/google/glog.svg" alt="Github stars" />
 &lt;a class="anchor" href="#googlegloghttpsgithubcomgoogleglog-github-starshttpsimgshieldsiogithubstarsgoogleglogsvg">#&lt;/a>
&lt;/h2>
&lt;p>C++ implementation of the Google logging module&lt;/p>
&lt;h2 id="grpchttpsgithubcomgrpcgrpc-github-starshttpsimgshieldsiogithubstarsgrpcgrpcsvg">
 &lt;a href="https://github.com/grpc/grpc">gRPC&lt;/a> &lt;img src="https://img.shields.io/github/stars/grpc/grpc.svg" alt="Github stars" />
 &lt;a class="anchor" href="#grpchttpsgithubcomgrpcgrpc-github-starshttpsimgshieldsiogithubstarsgrpcgrpcsvg">#&lt;/a>
&lt;/h2>
&lt;p>gRPC is a modern, open source, high-performance remote procedure call (RPC) framework that can run anywhere. gRPC enables client and server applications to communicate transparently, and simplifies the building of connected systems.&lt;/p>
&lt;p>grpc.io&lt;/p>
&lt;hr>
&lt;h2 id="web">
 web
 &lt;a class="anchor" href="#web">#&lt;/a>
&lt;/h2>
&lt;h3 id="ipkncrowhttpsgithubcomipkncrow-github-starshttpsimgshieldsiogithubstarsipkncrowsvg">
 &lt;a href="https://github.com/ipkn/crow">ipkn/crow&lt;/a> &lt;img src="https://img.shields.io/github/stars/ipkn/crow.svg" alt="Github stars" />
 &lt;a class="anchor" href="#ipkncrowhttpsgithubcomipkncrow-github-starshttpsimgshieldsiogithubstarsipkncrowsvg">#&lt;/a>
&lt;/h3>
&lt;p>Crow is very fast and easy to use C++ micro web framework (inspired by Python Flask)&lt;/p></description></item></channel></rss>