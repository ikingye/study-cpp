'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/study-cpp/docs/basic/spec/baidu/','title':"百度",'section':"1.3 编程规范",'content':"百度 C++ 编程规范 #  "});index.add({'id':1,'href':'/study-cpp/docs/basic/','title':"第一部分 基础入门",'section':"Docs",'content':"C++ (/ˌsiːˌplʌsˈplʌs/) 的发明人是 Bjarne Stroustrup (/ˈbjɑːrnə ˈstraʊstrʊp/, 1950/12/30, http://www.stroustrup.com)，\nC++ 的历史可以追溯到 1979，最初的灵感来自一种叫作 Simula 的语言。 起初，Bjarne Stroustrup 把他发明的语言称为 Cfront，1983 年更名为 C++。\n1998 年，C++ 标准委员会发布了第一个 C++ 国际标准 ISO/IEC 14882:1998，俗称 C++98。 C++98 包含了标准模板库 (Standard Template Library，STL)。\n2003 年，C++ 标准委员会修正了 C++98 的若干错误，发布了第二个 C++ 国际标准 ISO/IEC 14882:2003，俗称 C++03。\n之后，C++ 发展缓慢，直到 2011 年，C++ 标准委员会发布了第三个 C++ 国际标准 ISO/IEC 14882:2011，俗称 C++11。 C++11 是一次大改动，给 C++ 增加了一些很有用的功能，比如：右值引用 (Rvalue)、Lambda、对多线程的支持（包括原子操作）和智能指针等。 在 C++11 之后，C++ 标准委员会以每三年更新一次的速度向前推进 C++ 标准。\n2014 年发布 ISO/IEC 14882:2014，俗称 C++14。 C++14 只是小改动，主要修正 C++11 的错误，增加的功能不多，但包含了读写锁。\n2017 年发布 ISO/IEC 14882:2017，俗称 C++17。 C++17 增加了对文件系统的支持。\nC++20 在制定中。\n"});index.add({'id':5,'href':'/study-cpp/docs/basic/grammar/','title':"1.1 语法",'section':"第一部分 基础入门",'content':"C++ 语法 #  "});index.add({'id':6,'href':'/study-cpp/docs/basic/grammar/type/','title':"1.1.1 数据类型",'section':"1.1 语法",'content':"C++ 数据类型 #  "});index.add({'id':7,'href':'/study-cpp/docs/advanced/pattern/','title':"2.1 设计模式",'section':"第二部分 进阶实战",'content':"C++ 设计模式 #  "});index.add({'id':8,'href':'/study-cpp/docs/code/type/','title':"3.1 数据类型",'section':"第三部分 设计与实现",'content':"C++ 数据类型 #  "});index.add({'id':9,'href':'/study-cpp/docs/appendix/tutorial/','title':"4.1 教程",'section':"第四部分 附录",'content':"教程 #  基础 #   learn c++ in y minutes   C++ 后台开发有哪些练基础的开源项目？  yedf/handy     进阶 #  "});index.add({'id':10,'href':'/study-cpp/docs/basic/grammar/keyword/class/','title':"class",'section':"1.1.2 关键字",'content':"class #  建议：\n class 表示被封装的用户自定义类型，不公开定义非静态数据成员，一般通过成员方法进行交互。 struct 表示数据的简单集合，公开定义数据成员，只定义用于初始化数据成员的方法 (比如：构造 / 析构函数，initialize(), reset(), validate())。  // 简单的数据聚合，没有动作 struct Coordinate { int x; int y; int z; }; // 有动作的对象 class Cat { public: void meow(); private: ... }; class vs struct #   默认继承权限  class: private struct: public   成员的默认访问权限  class: private struct: public    除了这两点，class 和 struct 基本就是一个东西。\n"});index.add({'id':11,'href':'/study-cpp/docs/basic/grammar/keyword/vs-c/','title':"与 C 的差异",'section':"1.1.2 关键字",'content':"C++ 与 C 语言的差异 #    字符字面量的大小\n// 在C++中，字符字面量的大小是一个字节。 sizeof(\u0026#39;c\u0026#39;) == 1 // 在C语言中，字符字面量的大小与int相同。 sizeof(\u0026#39;c\u0026#39;) == sizeof(10)   函数原型与函数定义匹配\n// C++ 的函数原型与函数定义是严格匹配的 void func(); // 这个函数不能接受任何参数  // 而在C语言中 void func(); // 这个函数能接受任意数量的参数   NULL vs nullptr\n// 在 C++ 中，用 nullptr 代替 C 语言中的 NULL int* ip = nullptr;   同文件\n// C++ 也可以使用 C 语言的标准头文件， // 但是需要加上前缀 “c” 并去掉末尾的 “.h”。 #include \u0026lt;cstdio\u0026gt;  "});index.add({'id':12,'href':'/study-cpp/docs/basic/grammar/keyword/function/','title':"函数",'section':"1.1.2 关键字",'content':"函数 #  函数参数 #  参数默认值\n// 你可以为函数的参数指定默认值， // 默认参数必须放在所有的常规参数之后。 void doSomethingWithInts(int a, int b = 1, int c = 4) { } 函数重载 #  // C++支持函数重载，你可以定义一组名称相同而参数不同的函数 void print(char const* myString) { printf(\u0026#34;String %s\\n\u0026#34;, myString); } void print(int myInt) { printf(\u0026#34;My int is %d\u0026#34;, myInt); } int main() { print(\u0026#34;Hello\u0026#34;); // 解析为 void print(const char*)  print(15); // 解析为 void print(int) } "});index.add({'id':13,'href':'/study-cpp/docs/basic/others/practice/','title':"实践",'section':"1.4 其他",'content':"实践 #  "});index.add({'id':14,'href':'/study-cpp/docs/basic/grammar/keyword/pointer/','title':"指针",'section':"1.1.2 关键字",'content':"C++ 指针 #  智能指针 #     指针类别 支持 备注     unique_ptr C++ 11 拥有独有对象所有权语义的智能指针   shared_ptr C++ 11 拥有共享对象所有权语义的智能指针   weak_ptr C++ 11 到 std::shared_ptr 所管理对象的弱引用   auto_ptr C++ 17 中移除 拥有严格对象所有权语义的智能指针    unique_ptr #  std::unique_ptr 是通过指针占有并管理另一对象，并在 unique_ptr 离开作用域时释放该对象的智能指针。在下列两者之一发生时用关联的删除器释放对象：\n 销毁了管理的 unique_ptr 对象 通过 operator= 或 reset () 赋值另一指针给管理的 unique_ptr 对象。  shared_ptr #  std::shared_ptr 是通过指针保持对象共享所有权的智能指针。多个 shared_ptr 对象可占有同一对象。下列情况之一出现时销毁对象并解分配其内存：\n 最后剩下的占有对象的 shared_ptr 被销毁； 最后剩下的占有对象的 shared_ptr 被通过 operator= 或 reset () 赋值为另一指针。  有两种方式创建 shared_ptr ：\nvoid main( ) { shared_ptr\u0026lt;int\u0026gt; sptr1( new int ); // 使用 make_shared 宏可以加速创建的过程  // 因为 shared_ptr 主动分配内存并且保存引用计数 (reference count)  shared_ptr\u0026lt;int\u0026gt; sptr2 = make_shared\u0026lt;int\u0026gt;(100); } 参考：C++ 智能指针 - 内存泄露的惨痛经历\n "});index.add({'id':15,'href':'/study-cpp/docs/basic/others/standard/','title':"标准",'section':"1.4 其他",'content':"C++ 标准 #  参考：https://www.cnblogs.com/xuyaowen/p/c-cxx-standards.html\n"});index.add({'id':16,'href':'/study-cpp/docs/basic/others/version/','title':"版本",'section':"1.4 其他",'content':"C++ 版本 #  "});index.add({'id':17,'href':'/study-cpp/docs/basic/grammar/keyword/','title':"1.1.2 关键字",'section':"1.1 语法",'content':"C++ 关键字 #  这是 C++ 中的保留字列表。因为它们为语言所用，故这些关键词不可用于重定义或重载。\n注意 and、bitor、or、xor、compl、bitand、and_eq、or_eq、xor_eq、not 及 not_eq（还有双标符 \u0026lt;%、%\u0026gt;、\u0026lt;:、:\u0026gt;、%: 及 %:%:）提供标准记号的代用表示方法。\n参考：C++ 参考手册\n"});index.add({'id':18,'href':'/study-cpp/docs/basic/std/','title':"1.2 标准库",'section':"第一部分 基础入门",'content':"C++ 标准库 #  "});index.add({'id':19,'href':'/study-cpp/docs/advanced/algs/','title':"2.2 算法实现",'section':"第二部分 进阶实战",'content':"C++ 算法实现 #  "});index.add({'id':20,'href':'/study-cpp/docs/code/keyword/','title':"3.2 关键字",'section':"第三部分 设计与实现",'content':"C++ 关键字 #  "});index.add({'id':21,'href':'/study-cpp/docs/appendix/interview/','title':"4.2 面试题",'section':"第四部分 附录",'content':"面试题 #   你遇到过哪些高质量的 C++ 面试？ What is the best C++ interview question? [closed]  基础题 #  进阶题 #  为什么 C++ 的 member function template 不能是 virtual 的 #  比如，下面的代码是不合法的：\nclass Animal{ public: template\u0026lt;typename T\u0026gt; virtual void make_sound(){ //...  } }; 因为 C++ 的编译与链接模型是 \u0026ldquo;分离\u0026rdquo; 的 (至少是部分原因吧)。\n从 Unix/C 开始，一个 C/C++ 程序就可以被分开编译，然后用一个 linker 链接起来。这种模型有一个问题，就是各个编译单元可能对另一个编译单元一无所知。 一个 function template 最后到底会被 instantiate 为多少个函数，要等整个程序 (所有的编译单元) 全部被编译完成才知道。 同时，virtual function 的实现大多利用了一个 \u0026ldquo;虚函数表\u0026rdquo; 的东西，这种实现中，一个类的内存布局 (或者说虚函数表的内存布局) 需要在这个类编译完成的时候就被完全确定。 所以，由上面的矛盾可知，C++ 的 member function 不能既是 template 又是 virtual 的。\n参考：https://www.zhihu.com/question/60911582/answer/182045051\n"});index.add({'id':22,'href':'/study-cpp/docs/basic/grammar/keyword/namespace/','title':"命名空间",'section':"1.1.2 关键字",'content':"C++ 命名空间 #  // 命名空间为变量、函数和其他声明提供了分离的的作用域。 // 命名空间可以嵌套使用。  namespace First { namespace Nested { void foo() { printf(\u0026#34;This is First::Nested::foo\\n\u0026#34;); } } // 结束嵌套的命名空间Nested } // 结束命名空间First  namespace Second { void foo() { printf(\u0026#34;This is Second::foo\\n\u0026#34;) } } void foo() { printf(\u0026#34;This is global foo\\n\u0026#34;); } int main() { // 如果没有特别指定，就从“Second”中取得所需的内容。  using namespace Second; foo(); // 显示“This is Second::foo”  First::Nested::foo(); // 显示“This is First::Nested::foo”  ::foo(); // 显示“This is global foo” } "});index.add({'id':23,'href':'/study-cpp/docs/basic/grammar/keyword/reference/','title':"引用",'section':"1.1.2 关键字",'content':"C++ 引用 #    引用是一种特殊的指针类型，一旦被定义就不能重新赋值，并且不能被设置为空值。\n  使用引用时的语法与原变量相同\n 对引用类型进行解引用时，不需要使用 * 赋值时也不需要用 \u0026amp; 来取地址  using namespace std; string foo = \u0026#34;I am foo\u0026#34;; string bar = \u0026#34;I am bar\u0026#34;; string\u0026amp; fooRef = foo; // 建立了一个对foo的引用。 fooRef += \u0026#34;. Hi!\u0026#34;; // 通过引用来修改foo的值 cout \u0026lt;\u0026lt; fooRef; // \u0026#34;I am foo. Hi!\u0026#34; // 这句话的并不会改变fooRef的指向，其效果与“foo = bar”相同。 // 也就是说，在执行这条语句之后，foo == \u0026#34;I am bar\u0026#34;。 fooRef = bar;   不能修改一个常量引用的值\nconst string\u0026amp; barRef = bar; // 建立指向bar的常量引用。 // 和C语言中一样，（指针和引用）声明为常量时，对应的值不能被修改。 barRef += \u0026#34;. Hi!\u0026#34;; // 这是错误的，不能修改一个常量引用的值。   "});index.add({'id':24,'href':'/study-cpp/docs/basic/spec/','title':"1.3 编程规范",'section':"第一部分 基础入门",'content':"编程规范 #  "});index.add({'id':25,'href':'/study-cpp/docs/advanced/pkg/','title':"2.3 常用库",'section':"第二部分 进阶实战",'content':"C++ 常用库 #  "});index.add({'id':26,'href':'/study-cpp/docs/code/runtime/','title':"3.3 运行时",'section':"第三部分 设计与实现",'content':"C++ 运行时 #  "});index.add({'id':27,'href':'/study-cpp/docs/appendix/attention/','title':"4.3 关注项目",'section':"第四部分 附录",'content':"关注项目 #  google/glog #  C++ implementation of the Google logging module\ngRPC #  gRPC is a modern, open source, high-performance remote procedure call (RPC) framework that can run anywhere. gRPC enables client and server applications to communicate transparently, and simplifies the building of connected systems.\ngrpc.io\n web #  ipkn/crow #  Crow is very fast and easy to use C++ micro web framework (inspired by Python Flask)\n"});index.add({'id':28,'href':'/study-cpp/docs/basic/others/','title':"1.4 其他",'section':"第一部分 基础入门",'content':"其他 #  "});index.add({'id':29,'href':'/study-cpp/docs/advanced/snippet/','title':"2.4 代码片段",'section':"第二部分 进阶实战",'content':"C++ 代码片段 #  "});index.add({'id':30,'href':'/study-cpp/docs/advanced/test/','title':"2.5 测试",'section':"第二部分 进阶实战",'content':"C++ 测试 #  "});index.add({'id':31,'href':'/study-cpp/docs/advanced/prof/','title':"2.6 性能",'section':"第二部分 进阶实战",'content':"C++ 性能 #  "});index.add({'id':32,'href':'/study-cpp/docs/advanced/frame/','title':"2.7 框架",'section':"第二部分 进阶实战",'content':"C++ 框架 #  "});})();