'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/study-cpp/docs/appendix/tutorial/','title':"教程",'section':"第四部分 附录",'content':"教程 #  基础 #   learn c++ in y minutes  进阶 #  高阶 #  "});index.add({'id':1,'href':'/study-cpp/docs/basic/practice/spec/baidu/','title':"百度",'section':"编程规范",'content':"百度 C++ 编程规范 #  "});index.add({'id':3,'href':'/study-cpp/docs/basic/practice/spec/','title':"编程规范",'section':"最佳实践",'content':"编程规范 #  "});index.add({'id':4,'href':'/study-cpp/docs/basic/grammar/','title':"语法",'section':"第一部分 基础入门",'content':"C++ 语法 #  "});index.add({'id':5,'href':'/study-cpp/docs/appendix/interview/basic/','title':"基础",'section':"面试题",'content':"基础面试题 #  "});index.add({'id':7,'href':'/study-cpp/docs/appendix/interview/advanced/','title':"进阶",'section':"面试题",'content':"进阶面试题 #  "});index.add({'id':8,'href':'/study-cpp/docs/appendix/interview/','title':"面试题",'section':"第四部分 附录",'content':"面试题 #  基础题 #  进阶题 #  高阶题 #  "});index.add({'id':10,'href':'/study-cpp/docs/appendix/interview/expert/','title':"高阶",'section':"面试题",'content':"高阶面试题 #  "});index.add({'id':12,'href':'/study-cpp/docs/basic/grammar/keyword/','title':"关键字",'section':"语法",'content':"C++ 关键字 #  这是 C++ 中的保留字列表。因为它们为语言所用，故这些关键词不可用于重定义或重载。\n注意 and、bitor、or、xor、compl、bitand、and_eq、or_eq、xor_eq、not 及 not_eq（还有双标符 \u0026lt;%、%\u0026gt;、\u0026lt;:、:\u0026gt;、%: 及 %:%:）提供标准记号的代用表示方法。\n参考：C++ 参考手册\n"});index.add({'id':13,'href':'/study-cpp/docs/basic/grammar/vs-c/','title':"与 C 的差异",'section':"语法",'content':"C++ 与 C 语言的差异 #   字符字面量的大小 // 在C++中，字符字面量的大小是一个字节。 sizeof(\u0026#39;c\u0026#39;) == 1 // 在C语言中，字符字面量的大小与int相同。 sizeof(\u0026#39;c\u0026#39;) == sizeof(10)  函数原型与函数定义匹配 // C++ 的函数原型与函数定义是严格匹配的 void func(); // 这个函数不能接受任何参数  // 而在C语言中 void func(); // 这个函数能接受任意数量的参数  NULL vs nullptr // 在 C++ 中，用 nullptr 代替 C 语言中的 NULL int* ip = nullptr;  同文件 // C++ 也可以使用 C 语言的标准头文件， // 但是需要加上前缀 “c” 并去掉末尾的 “.h”。 #include \u0026lt;cstdio\u0026gt;  "});index.add({'id':14,'href':'/study-cpp/docs/basic/grammar/function/','title':"函数",'section':"语法",'content':"函数 #  函数参数 #  参数默认值\n// 你可以为函数的参数指定默认值， // 默认参数必须放在所有的常规参数之后。 void doSomethingWithInts(int a, int b = 1, int c = 4) { } 函数重载 #  // C++支持函数重载，你可以定义一组名称相同而参数不同的函数 void print(char const* myString) { printf(\u0026#34;String %s\\n\u0026#34;, myString); } void print(int myInt) { printf(\u0026#34;My int is %d\u0026#34;, myInt); } int main() { print(\u0026#34;Hello\u0026#34;); // 解析为 void print(const char*)  print(15); // 解析为 void print(int) } "});index.add({'id':15,'href':'/study-cpp/docs/basic/grammar/pointer/','title':"指针",'section':"语法",'content':"C++ 指针 #  智能指针 #     指针类别 支持 备注     unique_ptr C++ 11 拥有独有对象所有权语义的智能指针   shared_ptr C++ 11 拥有共享对象所有权语义的智能指针   weak_ptr C++ 11 到 std::shared_ptr 所管理对象的弱引用   auto_ptr C++ 17 中移除 拥有严格对象所有权语义的智能指针    unique_ptr #  std::unique_ptr 是通过指针占有并管理另一对象，并在 unique_ptr 离开作用域时释放该对象的智能指针。在下列两者之一发生时用关联的删除器释放对象：\n 销毁了管理的 unique_ptr 对象 通过 operator= 或 reset () 赋值另一指针给管理的 unique_ptr 对象。  shared_ptr #  std::shared_ptr 是通过指针保持对象共享所有权的智能指针。多个 shared_ptr 对象可占有同一对象。下列情况之一出现时销毁对象并解分配其内存：\n 最后剩下的占有对象的 shared_ptr 被销毁； 最后剩下的占有对象的 shared_ptr 被通过 operator= 或 reset () 赋值为另一指针。  有两种方式创建 shared_ptr ：\nvoid main( ) { shared_ptr\u0026lt;int\u0026gt; sptr1( new int ); // 使用 make_shared 宏可以加速创建的过程  // 因为 shared_ptr 主动分配内存并且保存引用计数 (reference count)  shared_ptr\u0026lt;int\u0026gt; sptr2 = make_shared\u0026lt;int\u0026gt;(100); } 参考：C++ 智能指针 - 内存泄露的惨痛经历\n "});index.add({'id':16,'href':'/study-cpp/docs/basic/practice/','title':"最佳实践",'section':"第一部分 基础入门",'content':"最佳实践 #  "});index.add({'id':17,'href':'/study-cpp/docs/basic/version/','title':"版本",'section':"第一部分 基础入门",'content':"C++ 版本 #  "});index.add({'id':18,'href':'/study-cpp/docs/basic/grammar/namespace/','title':"命名空间",'section':"语法",'content':"C++ 命名空间 #  // 命名空间为变量、函数和其他声明提供了分离的的作用域。 // 命名空间可以嵌套使用。  namespace First { namespace Nested { void foo() { printf(\u0026#34;This is First::Nested::foo\\n\u0026#34;); } } // 结束嵌套的命名空间Nested } // 结束命名空间First  namespace Second { void foo() { printf(\u0026#34;This is Second::foo\\n\u0026#34;) } } void foo() { printf(\u0026#34;This is global foo\\n\u0026#34;); } int main() { // 如果没有特别指定，就从“Second”中取得所需的内容。  using namespace Second; foo(); // 显示“This is Second::foo”  First::Nested::foo(); // 显示“This is First::Nested::foo”  ::foo(); // 显示“This is global foo” } "});index.add({'id':19,'href':'/study-cpp/docs/basic/grammar/reference/','title':"引用",'section':"语法",'content':"C++ 引用 #    引用是一种特殊的指针类型，一旦被定义就不能重新赋值，并且不能被设置为空值。\n  使用引用时的语法与原变量相同\n 对引用类型进行解引用时，不需要使用 * 赋值时也不需要用 \u0026amp; 来取地址  using namespace std; string foo = \u0026#34;I am foo\u0026#34;; string bar = \u0026#34;I am bar\u0026#34;; string\u0026amp; fooRef = foo; // 建立了一个对foo的引用。 fooRef += \u0026#34;. Hi!\u0026#34;; // 通过引用来修改foo的值 cout \u0026lt;\u0026lt; fooRef; // \u0026#34;I am foo. Hi!\u0026#34; // 这句话的并不会改变fooRef的指向，其效果与“foo = bar”相同。 // 也就是说，在执行这条语句之后，foo == \u0026#34;I am bar\u0026#34;。 fooRef = bar;   不能修改一个常量引用的值\nconst string\u0026amp; barRef = bar; // 建立指向bar的常量引用。 // 和C语言中一样，（指针和引用）声明为常量时，对应的值不能被修改。 barRef += \u0026#34;. Hi!\u0026#34;; // 这是错误的，不能修改一个常量引用的值。   "});})();