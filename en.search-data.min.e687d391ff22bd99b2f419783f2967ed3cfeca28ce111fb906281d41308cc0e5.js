'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/study-cpp/docs/appendix/tutorial/','title':"教程",'content':"教程 基础  learn c++ in y minutes  进阶 高阶 "});index.add({'id':1,'href':'/study-cpp/docs/basic/practice/spec/baidu/','title':"百度",'content':"百度 C++ 编程规范 "});index.add({'id':2,'href':'/study-cpp/docs/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':3,'href':'/study-cpp/docs/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':4,'href':'/study-cpp/docs/basic/grammar/','title':"语法",'content':"C++ 语法 "});index.add({'id':5,'href':'/study-cpp/docs/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':6,'href':'/study-cpp/docs/principle/','title':"第二部分 原理",'content':""});index.add({'id':7,'href':'/study-cpp/docs/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':8,'href':'/study-cpp/docs/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':9,'href':'/study-cpp/docs/source/','title':"第三部分 源码实现",'content':""});index.add({'id':10,'href':'/study-cpp/docs/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':11,'href':'/study-cpp/docs/appendix/','title':"第四部分 附录",'content':""});index.add({'id':12,'href':'/study-cpp/docs/basic/grammar/keyword/','title':"关键字",'content':"C++ 关键字 这是 C++ 中的保留字列表。因为它们为语言所用，故这些关键词不可用于重定义或重载。\n注意 and、bitor、or、xor、compl、bitand、and_eq、or_eq、xor_eq、not 及 not_eq（还有双标符 \u0026lt;%、%\u0026gt;、\u0026lt;:、:\u0026gt;、%: 及 %:%:）提供标准记号的代用表示方法。\n参考：C++ 参考手册\n"});index.add({'id':13,'href':'/study-cpp/docs/basic/grammar/vs-c/','title':"与 C 的差异",'content':"C++ 与 C 语言的差异  字符字面量的大小 // 在C++中，字符字面量的大小是一个字节。 sizeof(\u0026#39;c\u0026#39;) == 1 // 在C语言中，字符字面量的大小与int相同。 sizeof(\u0026#39;c\u0026#39;) == sizeof(10)  函数原型与函数定义匹配 // C++ 的函数原型与函数定义是严格匹配的 void func(); // 这个函数不能接受任何参数  // 而在C语言中 void func(); // 这个函数能接受任意数量的参数  NULL vs nullptr // 在 C++ 中，用 nullptr 代替 C 语言中的 NULL int* ip = nullptr;  同文件 // C++ 也可以使用 C 语言的标准头文件， // 但是需要加上前缀 “c” 并去掉末尾的 “.h”。 #include \u0026lt;cstdio\u0026gt;  "});index.add({'id':14,'href':'/study-cpp/docs/basic/grammar/function/','title':"函数",'content':"函数 函数参数 参数默认值\n// 你可以为函数的参数指定默认值， // 默认参数必须放在所有的常规参数之后。 void doSomethingWithInts(int a, int b = 1, int c = 4) { } 函数重载 // C++支持函数重载，你可以定义一组名称相同而参数不同的函数 void print(char const* myString) { printf(\u0026#34;String %s\\n\u0026#34;, myString); } void print(int myInt) { printf(\u0026#34;My int is %d\u0026#34;, myInt); } int main() { print(\u0026#34;Hello\u0026#34;); // 解析为 void print(const char*)  print(15); // 解析为 void print(int) } "});index.add({'id':15,'href':'/study-cpp/docs/basic/practice/','title':"最佳实践",'content':"最佳实践 "});index.add({'id':16,'href':'/study-cpp/docs/basic/version/','title':"版本",'content':"C++ 版本 "});index.add({'id':17,'href':'/study-cpp/docs/basic/grammar/namespace/','title':"命名空间",'content':"C++ 命名空间 // 命名空间为变量、函数和其他声明提供了分离的的作用域。 // 命名空间可以嵌套使用。  namespace First { namespace Nested { void foo() { printf(\u0026#34;This is First::Nested::foo\\n\u0026#34;); } } // 结束嵌套的命名空间Nested } // 结束命名空间First  namespace Second { void foo() { printf(\u0026#34;This is Second::foo\\n\u0026#34;) } } void foo() { printf(\u0026#34;This is global foo\\n\u0026#34;); } int main() { // 如果没有特别指定，就从“Second”中取得所需的内容。  using namespace Second; foo(); // 显示“This is Second::foo”  First::Nested::foo(); // 显示“This is First::Nested::foo”  ::foo(); // 显示“This is global foo” } "});index.add({'id':18,'href':'/study-cpp/docs/basic/grammar/reference/','title':"引用",'content':"C++ 引用   引用是一种特殊的指针类型，一旦被定义就不能重新赋值，并且不能被设置为空值。\n  使用引用时的语法与原变量相同\n 对引用类型进行解引用时，不需要使用 * 赋值时也不需要用 \u0026amp; 来取地址  using namespace std; string foo = \u0026#34;I am foo\u0026#34;; string bar = \u0026#34;I am bar\u0026#34;; string\u0026amp; fooRef = foo; // 建立了一个对foo的引用。 fooRef += \u0026#34;. Hi!\u0026#34;; // 通过引用来修改foo的值 cout \u0026lt;\u0026lt; fooRef; // \u0026#34;I am foo. Hi!\u0026#34; // 这句话的并不会改变fooRef的指向，其效果与“foo = bar”相同。 // 也就是说，在执行这条语句之后，foo == \u0026#34;I am bar\u0026#34;。 fooRef = bar;   不能修改一个常量引用的值\nconst string\u0026amp; barRef = bar; // 建立指向bar的常量引用。 // 和C语言中一样，（指针和引用）声明为常量时，对应的值不能被修改。 barRef += \u0026#34;. Hi!\u0026#34;; // 这是错误的，不能修改一个常量引用的值。   "});index.add({'id':19,'href':'/study-cpp/categories/','title':"Categories",'content':""});index.add({'id':20,'href':'/study-cpp/docs/','title':"Docs",'content':""});index.add({'id':21,'href':'/study-cpp/tags/','title':"Tags",'content':""});index.add({'id':22,'href':'/study-cpp/','title':"首页",'content':""});})();